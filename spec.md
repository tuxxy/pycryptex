# Cryptex Spec

The specification described in this document is currently version 1.0 of the Cryptex format.

Cryptex takes a user-provided message (an arbitrary amount of bytes), a key (32 bytes), and a TTL, or time to live, in seconds (as an eight byte integer). Cryptex produces a _token_ that contains an encrypted form of the message provided. The encrypted message cannot be read or modified without the key.

Cryptex is meant to be used as a replacement for the Fernet specification and does not intend to offer compatibility with it.

All encryption is done with AES-256 in GCM mode.

All base 64 encoding is done with the "URL and Filename Safe" variant, defined in [RFC 4648](https://tools.ietf.org/html/rfc4648#section-5) as "base64url".

## Key Format

A Cryptex key is a base64url encoding of 32 securely random generated bytes.

```
base64url(secure_random(32))
```

## Cryptex Token

```
Timestamp ‖ Tag ‖ Nonce ‖ Ciphertext
```

* TTL, 8 bytes
* Tag, 16 bytes
* Nonce, 12
* Ciphertext, variable length

Cryptex tokens are not self-delimiting. It is assumed that the transport will provide a means of finding the length of each complete Cryptex token.

## Token Fields

### Timestamp

This field is an 8 byte (64 bit) unsigned big-endian integer. It is the number of seconds that the Cryptex token should remain valid for added to the number of seconds elapsed between January 1, 1970 UTC and the time of generation.

```
Timestamp = Epoch() + TTL
```

### Tag

This field is a 16 byte (128 bit) GMAC digest that is used to authenticate the ciphertext during decryption via the GCM cipher mode.

### Nonce

This field is a 12 byte (96 bit) random number that is used to initialize the AES block cipher in GCM mode. This Nonce should be unique and never be repeated.

### Ciphertext

This field has variable size. It contains the original input message, encrypted. The use of the GCM cipher mode dictates that this field does not need to be padded before encryption.

```
Timestamp ‖ Tag ‖ Nonce ‖ Ciphertext
```

## Generating

Given a key and message, generate a Cryptex token with the following steps, in order:

1. Generate a 12 byte unique nonce using a secure random source (such as /dev/urandom).
2. Record the current epoch time and add the TTL to it.
    1. If no TTL is provided, record the timestamp as eight bytes of 0.
3. Construct the ciphertext:
    1. Add the timestamp as authenticated data to the cipher.
    2. Encrypt the plaintext message. Padding is _not_ needed.
4. Construct the GMAC tag by getting the digest of the cipher's GHASH function.
5. Concatenate the fields together in the format described above.
6. base64url encode the entire token.

## Verifying

Given a key and a token, to verify that the token is valid and recover the original plaintext message, perform the following steps, in order:

1. base64url decode the token.
2. Strip the token into each of its components.
3. Record the current epoch time.
3. Reconstruct the plaintext:
    1. Add the timestamp from the token as authenticated data to the cipher.
    2. Decrypt the ciphertext.
4. Authenticte the ciphertext with the cipher's GHASH function.
5. Check the token's expiration:
    1. If the timestamp is 0, the user has not specified a TTL.
    2. If the recorded current epoch time is greater than the timestamp, the token is expired.
    3. If the token isn't expired, the plaintext is safe to return.
